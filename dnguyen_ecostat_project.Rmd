---
title: "Deterministic and stochastic effects of food quality on extinction time"
author: "David Nguyen"
date: "October 20, 2020"
output: "pdf_document"
  # html_document:
  #   code_folding: hide
# output:
#   word_document: default
bibliography: nres803.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE)
library(tidyverse)
library(readxl)
library(broom.mixed)
library(nlme)
```

```{r munge_data, include = FALSE}
# get names of sheets that contain pop data (not including T15-8 for now)
sheet_names <- excel_sheets("weevil_data/pop_dynamics_expt_data.xlsx")
sheet_pops <- sheet_names[1:5]
pct_peanut_shells <- c(0, 0.03, 0.05, 0.10, 0.15)

# create new colnames
npop <- 10
date_cols <- c("days", "date")
demo_cols <- unlist(lapply(1:npop,
       function(i)
         c(paste0("m_alive_",i),
           paste0("f_alive_",i),
           paste0("total_alive_", i),
           paste0("m_dead_",i),
           paste0("f_dead_",i),
           paste0("total_dead_",i))))
treatment_cols <- c("m_added", "f_added", "pellets", "noclue", "treatment")

# read-in and reformat all population data sheets

list_dfs <- vector("list", length = length(sheet_pops)) # init list to store each df

# loop to read and reformat
for (i in seq_along(sheet_pops)) {
  df_now <-
    read_excel("weevil_data/pop_dynamics_expt_data.xlsx",
               skip = 3,
               sheet = sheet_pops[i]) %>%
    mutate(treatment = pct_peanut_shells[i])
  
  # assign new colnames
  names(df_now) <-
    c(date_cols, demo_cols, treatment_cols) # should include check to make sure all data sheets have same format
  
  # T15 has weird ??? in a col. CHange to NA and convert col to numeric
  if (i == 5) {
    df_now$m_alive_8 <-
      df_now %>% 
      mutate_at(vars('m_alive_8'), ~na_if(., '???')) %>%
      pull(m_alive_8) %>%
      as.numeric()
  }
  
  # make data longer for plotting
  df_long <- df_now %>%
    select(-pellets,-noclue) %>% # always 2 pellets a day, and drop noclue as well as the num. added
    filter(!is.na(days)) %>%  # drop empty bottom two rows (included when reading due to sum(pellets) in spread sheet)
    pivot_longer(
      -c(days, date, m_added, f_added,treatment),
      names_sep = "_",
      names_to = c("sex", "status", "replicate"),
      values_to = "count"
    ) %>%
    # original data file did not have totals computed for all days
    # create new df with totals for all days
    filter(sex != "total" , status == "alive") %>%
    group_by(date, replicate) %>%
    mutate(total = sum(count, na.rm = TRUE)) %>% # females were not observed after first few days
    ungroup()
  
  # save to list
  list_dfs[[i]] <- df_long
}

full_df <- bind_rows(list_dfs)

full_df <- full_df %>% mutate(replicate = as.numeric(replicate))
#full_df$treatment <- as_factor(full_df$treatment) # for proper facetting when plotting. Should convert to numeric instead.
```

```{r clean_for_analysis, warning = FALSE}
# verify that "total" is the same regardless of sex (which wasn't actually distinguished during expt)
# all.equal( filter(full_df, sex == "m") %>% pull(total), filter(full_df, sex == "f") %>% pull(total) )
weevil <-
  full_df %>%
  filter(sex == "m",  # remove duplicate rows of "total"
         is.na(m_added)) %>% # Only include data after initialization complete
  select(days, treatment, replicate, total) %>% # drop all unimportant cols
  filter(treatment != 0.03) # drop 3 % shell treatment, since it is diff length and was only initialized 20 days instead of 32 like others

# set all "total" values to NA after extinction
# I will define exinction as the last time the cumulative population total increases
# e.g., take cumsum for all trt X rep combinations, then get index where cumsum(total) == max(cumsum), set all total values afterwards to NA

weevil <- 
  weevil %>% 
  group_by(treatment, replicate) %>%
  mutate(cumtotal = cumsum(total), 
         max_cumtotal = max(cumtotal)) %>%
  rowwise() %>%
  mutate(last_day = ifelse( (cumtotal == max_cumtotal) && (total == 0), days, NA)) %>%
  group_by(treatment, replicate) %>%
  mutate(last_day = min(last_day, na.rm = TRUE)) %>%
  mutate(total = ifelse(days > last_day, NA, total)) %>%
  mutate(last_day = ifelse(last_day == Inf, NA, last_day)) %>%
  # get next total, ln(abundance + 1), compute r, and make a new treatment col that is a factor
  mutate(next_total = lead(total),
         l_total = log(total + 1),
         l_next_total = log(next_total + 1),
         r = log((next_total + 1)/(total + 1)),
         ftreatment = factor(treatment, levels = c("0", "0.05", "0.1", "0.15")),
         freplicate = factor(replicate, levels = as.character(1:10)),
         time = (days - 32)/4) %>%
  unite(c("ftreatment", "replicate"), col = "rep_trt", remove = FALSE)
```

```{r define_sim_gomp}
sim_log_gomp <- function (xinit,     # initial log population size
                     lambda, # population growth rate,
                     b,      # density dependence
                     sd_proc, # process noise: N(0, sd_proc)
                     tfinal,
                     nsim,
                     replicate,
                     ftreatment) {
  
  # init storage list for all simulation
  sim_list <- vector("list", length = nsim)
  
  for (i in seq_along(sim_list)) {
    # init storage for current simulation
    log_x <- vector("numeric", length = tfinal)
    log_x[1] <- xinit
    
    # sim population dynamics
    for (j in 2:tfinal) {
      proc_error <- rnorm(n = 1, mean = 0, sd = sd_proc)
      log_x[j] <- lambda + b * log_x[j-1] + proc_error
    }
    # save current simulation
    sim_list[[i]] <- (tidyr::tibble(time = 1:tfinal,
                                    log_x = log_x,
                                    N = exp(log_x),
                                    lambda = lambda,
                                    b_ = b,
                                    sd_proc = sd_proc,
                                    replicate = replicate,
                                    ftreatment = ftreatment))
  } 
  out <- dplyr::bind_rows(sim_list, .id = "sim")
  return(out)
}
```

# Introduction

Habitat degredation a major threat to animal populations [@sala_global_2000]. As a consequence, food quality may also be reduced which are known to have strong impacts on individual and population level growth [@awmack_host_2002; @griffen_effects_2008]. Poor food quality typically decrease fecundity and increase development time which may, in turn, reduce population level growth rates and carrying capacity. In experimental studies, the effects of food quality on population parameters are quantified by including food quality as a covariate for estimating population parameters; however, to the best of my knowledge, the effect of food quality on the variability of population parameters is not routinely quantified despite clear signals of food-quality specific variability in experimental data [cf. figure 2 in @griffen_effects_2008].

Both deterministic and stochastic forces drive population dynamics and extinction risk [@bjornstad_noisy_2001; @fung_partitioning_2019]. For example, low population growth rates are a deterministic driver of population declines whereas variability in population growth rates is a stochastic driver of increased extinction risk [@vucetich_population_2000]. Appropriately modeling the sources of stochasticity is important for accurate modeling of population dynamics and extinction risk [@melbourne_extinction_2008]. Therefore, when modeling the effect of a food quality on population growth it may be important to consider both fixed and random effects for accurate assessments of extinction risk.

The main objective of this analysis was to identify the relative contributions of the deterministic and stochastic impact of resource quality on extinction time. Food quality may impact populations deterministically by affecting population growth rate and/or carrying capacity and stochastically by increasing variability of environmental noise. I used existing time-series data of southern cowpea weevil (*Callosobruchus maculatus*) populations that had been experimentally subjected to differing food quality treatments (M. Dyck unpublished). To quantify the contribution of deterministic and stochastic effects of food quality, I fitted a set of population models to the bean weevil data that allow for: 1. Growth rate and density dependence to vary with food quality; 2. An additive effect of food quality on environmental noise; 3. Both 1 and 2. This set of models represent a deterministic effect only, a stochastic effect only, and both deterministic and stochastic effects of food quality, respectivelly. A fourth model was fit that allowed for a random effect of population (replicate x treatment combination) on the population growth rate in case there was variation among population not accounted for by the treatment. These models were compared by AIC to quantify support for each of the possible hypotheses. Goodness of fit for the best supported model was visually assessed by comparing model predictions and experimental observations. Metrics for assessing goodness of fit included: carrying capacity, population trajectories, the extinction frequency, and the mean and distribution of extinction times. 

The model that included both a deterministic and stochastic effect of food quality on bean weevil population dynamics was best supported by the data. However, the best model was a poor fit to all the > 0 % peanut shell treatments since the model could not produce the population cycles characteristic of these populations, and instead absorbed the deterministic population cycles into the treatment specific residual variance. Hence, this analysis is inadequate for drawing any conclusion about the relative contributions of deterministic and stochastic effects of resource limitation on population dynamics and extinction because the model could not describe the mean dynamics of the data. Potential solutions to this problem are discussed.

# Materials and methods

### Bean weevil population data

The quality of food provided to the weevils was experimentally manipulated by manufacturing artificial bean pellets made from ground black-eyed pea powder and varying percentages of powdered peanut shells (0, 3, 5, 10, and 15 %). Larger percentages of peanut shell simulate lower food quality.  To initialize each replicate population, two males and two females from a population reared on whole chickpeas were added every four days for the first 28 days of the experiment. After this initialization, two fresh bean pellets were added weekly without any further addition of adults. There were 10 replicate populations allocated to each treatment resulting in a total of 50 population time-series. Populations were maintained until the populations crashed or were stopped after 632 days . A complete census of adult bean weevils was conducted every four days but the adults were not sexed and there was no count of eggs, larvae, or pupa (M. Dyck, unpublished).

### Model structure, fitting, and comparison

The discrete-time stochastic Gompertz model was fit to the remainder of weevil abundances after the initialization phase is removed. The Gompertz model is commonly used for modeling ecological populations [@dennis_estimating_2006]. The model were fit using a one-step fitting procedure which estimates process noise but not observation noise [@bolker_ecological_2008]. This is an appropriate assumption for these data  since the adult weevil populations were completely censused at each time point. 

The full model is as follows:

$$y_{t+1,i,j} = a_i + b_i y_t + p_{ij} + \epsilon_{t,i,j}$$
$$\epsilon_{t,i,j} \sim N(0,\sigma_i^2)\\$$
$$p_{ij} \sim N(0, \sigma_{pop}^2)$$

Where $\ln(N_{t,i,j} + 1) = y_{t,i,j}$ is the log-population abundance at times $t$ for peanut shell percentages $i = 0, 5, 10, 15$ and replicates $j = 1, \ldots, 10$. The deterministic (fixed-effect) of food quality operates on weevil populations are represented by the population growth rate ($a_i$) and the strength of density dependence ($b_i$). The stochastic (random-effect) of food quality on weevil populations are represented by a food-specific residual error (process noise) of population growth from time step $t$ to $t+1$. The random effect of bean weevil population is denoted $p_{ij}$.

The model that includes only the deterministic impact of food quality is obtained by dropping the treatment index from the residual variance term. The model for only the stochastic impact of food quality is obtained by estimating a common population growth rate ($a$) and density dependence coefficient ($b$) across all food quality treatments while maintaing a treatment specific residual variance. The random effect can be omitted by dropping it from the model.

Each of these four models was fit using the nlme package using the gls() or lme() functions as appropriate. Model comparison was done by AIC.

### Evaluating goodness of fit

Assessing the goodness of fit for noisy populations is challenging because sensitivity to small changes in initial conditions and process noise may generate very different population trajectories [@wood_statistical_2010]. To avoid these issues, I assessed goodness of fit by comparing summary statistics of the observed data to the same summary statistics computed for simulated output. To do this, I simulated the Gompertz model using the point estimates from the best model for the same number of time steps as the experimental populations were observed and the same number of replicates used in the experiment. The statistics and observable parameters I used to assess model fit were: 

1. The model predicted $\ln(\text{abundance} + 1)$ carrying capacity (estimated as in @dennis_estimating_2006) and the average observed $\ln(\text{abundance} + 1)$.
1. 95 % prediction interval (computed from 8000 total simulated populations, i.e., 200 simulations for each replicate x treatment combination) and observed population trajectories.
1. The distribution of time to extinction (abundance $\leq$ 0 on arithmetic scale), conditioned on having observed extinctions.
1. The frequency of populations that became extinct.

# Results

### Model comparison

```{r fit_models}
# treatment specific growth rate and density dependnece
# homogenous variance
m1 <- gls(l_next_total ~ l_total*ftreatment - 1, 
    data = weevil, 
    method = "ML",
    na.action=na.omit)

# common growth rate and density dependnece
# treatment specific variance
m2 <- 
  gls(l_next_total ~ l_total - 1, 
    data = weevil, 
    weights = varIdent(form = ~1 | ftreatment), # factor specific residual variance
    method = "ML",
    na.action=na.omit)

# treatment specific growth rate and density dependnece
# treatment specific variance
m3 <- 
  gls(l_next_total ~ l_total*ftreatment -1, 
    data = weevil, 
    weights = varIdent(form = ~1 | ftreatment), # factor specific residual variance
    method = "ML",
    na.action=na.omit)

# treatment specific growth rate and density dependnece
# treatment specific variance
# random intercept of rep:trt (which is replicate nested in treatment)
m4 <- lme(l_next_total ~ l_total*ftreatment - 1, 
    random = ~ 1 | rep_trt,
    data = weevil, 
    weights = varIdent(form = ~1 | ftreatment), # factor specific residual variance
    method = "ML",
    na.action=na.omit) # ignore na values

# treatment specific growth rate and density dependnece
# treatment specific variance
# random intercept and slope of rep:trt (which is replicate nested in treatment
# I'm not sure if this is specified correctly
# m5 <- lme(l_next_total ~ l_total*ftreatment - 1, 
    # random = ~ 1 + ftreatment| rep_trt,
    # data = weevil, 
    # weights = varIdent(form = ~1 | ftreatment), # factor specific residual variance
    # method = "ML",
    # na.action=na.omit) # ignore na values
```

```{r eval = FALSE}
m3_drop8 <- 
  gls(l_next_total ~ l_total*ftreatment -1, 
    data = weevil %>% filter(!(ftreatment == 0.15 & replicate == 8)), 
    weights = varIdent(form = ~1 | ftreatment), # factor specific residual variance
    method = "ML",
    na.action=na.omit)

summary(m3_drop8)
```


```{r aic_table}
AIC(m1, m2, m3, m4) %>%
  mutate(delta = AIC - min(AIC),
         weight = exp(-delta/2),
         weight = weight/sum(weight)) %>%
  add_column(model = c("model 1", "model 2", "model 3", "model 4")) %>%
  add_column(`log likelihood` = c(m1$logLik, m2$logLik, m3$logLik, m4$logLik)) %>%
  select(model,`log likelihood`, df, AIC, delta, weight) %>%
  knitr::kable(digits = 2, caption = "Model comparison")
```

The model with the highest AIC weight was model 3 which included a deterministic and stochastic effect of food quality on population dynamics and had no random effect of population (replicate x treatment combination) on population growth rate (a). Model 4 which is the same as model 3 but including the random effect had a difference in AIC of 2 which indicates that the model is not more likely than model 3 and the only difference is the additional parameter estimated for the random effect variance component. The deterministic only (model 1) and stochastic only (model 2) have no credibility given the observed data (table 1.).

Overall, model checking indicates that the model assumptions were largely satisfied for the 0 % peanut shell population but were not satistfied or all other treatment levels. There was some heteroscedasticity in residual variance for all treatment levels. The residual variance was larger for smaller fitted values. The heteroscedasticity was weakest for the 0 % treatment and stronger for all other treatment levels. There was some temporal autocorrelation for the 5 % treatment and strong temporal autocorrelation for the 10 and 15 % treatments. The distribution of residuals was non-normal (heavy tailed) for treatment levels 5 - 15 %.

Model regression fit and diagnostics for the top model (deterministic and stochastic effect) are included in the appendix A2. 
```{r AIC_5, eval = FALSE}
AIC(m1, m2, m3, m4, m5) %>%
  mutate(delta = AIC - min(AIC),
         weight = exp(-delta/2),
         weight = weight/sum(weight)) %>%
  add_column(model = c("model 1", "model 2", "model 3", "model 4", "model 5")) %>%
  select(model, df, AIC, delta, weight) %>%
  knitr::kable(digits = 3)
```

```{r augment_m3}
m3_aug <- 
  augment(m3, weevil) %>%
  rename(residuals = .resid, fitted = .fitted)
```


```{r eval = FALSE}
# get coef from m4
coef(m4) %>%
  as_tibble(rownames = "treatment_replicate") %>%
  separate(treatment_replicate, sep = "_", into = c("treatment", "replicate"))
```


```{r get_m3_trt_sd}
# try to calculate factor-specific residual SE
df_m3 <- 12 # residual df (I think??? Not sure how this works with factor specific var) 

var_est_trt <- m3_aug %>%
  group_by(ftreatment) %>%
  mutate(sd_resid = sd(residuals), # directly calculate sd ### this is wrong!!!!
         sq_resid = sum(residuals^2),
         nobs = n()) %>%
  # this is the correct sd!
  mutate(se_resid = sqrt(sq_resid/ (nobs - df_m3))) %>% # calculate sqrt(SSE/df_error)
  summarize(sd_resid, se_resid) %>%  
  slice(1) %>%
  select(ftreatment, trt_resid = se_resid)
```

# Parameter estimates for top model

```{r confidence_int}
# get CI for a and b estimates of model 3
m3_int <- intervals(m3)
m3_int_coef <- m3_int$coef %>%
  as_tibble(rownames = "coefficient") %>%
  mutate(parameter_sym = case_when(str_detect(coefficient, "l_total") ~ "b",
                                 str_detect(coefficient, "ftreatment") ~ "a",
                                 TRUE ~ coefficient),
         parameter = case_when(parameter_sym == "a" ~ "population growth rate (a)",
                               parameter_sym == "b" ~ "density dependence (b)")) %>%
  mutate(treatment = str_remove_all(coefficient, "[[:alpha:]|:|_]"), # keep only numbers and decimal point
         treatment = ifelse(treatment == "", "0", treatment),
         treatment = factor(treatment, levels = c("0", "0.05","0.1","0.15"))) %>%
  mutate(`estimate (95 % CI)` = paste(round(est.,2), " (", round(lower,2), ", ", round(upper,2), ")"))

# get trt specific sd
m3_int_sigma <- 
  m3_int$sigma %>%
  as_tibble(rownames = "estimate") %>%
  pivot_wider(names_from = "estimate", values_from = "value") %>%
  add_column(treatment = factor(0, levels = c("0", "0.05","0.1","0.15")))

m3_int_varStruct <- 
  m3_int$varStruct %>%
  as_tibble(rownames = "treatment") %>%
  mutate(treatment = factor(treatment, levels = c("0", "0.05","0.1","0.15")))

m3_int_sd <-  bind_rows(m3_int_sigma, m3_int_varStruct) %>%
  mutate(lower = ifelse(treatment != 0, lower*m3_int_sigma$lower, lower),
         est. = ifelse(treatment != 0, est. * m3_int_sigma$est., est.),
         upper = ifelse(treatment != 0, upper * m3_int_sigma$upper, upper)) %>%
  mutate(`estimate (95 % CI)` = paste(round(est.,2), " (", round(lower,2), ", ", round(upper,2), ")")) %>%
  mutate(parameter = "process noise (sd)")

# combine coef and sd tibbles
m3_int_table <- full_join(m3_int_coef, m3_int_sd)

# table
m3_int_table %>% select(treatment, parameter, `estimate (95 % CI)`) %>%
  pivot_wider(names_from = parameter, values_from = `estimate (95 % CI)`) %>%
  knitr::kable(caption = "Parameter estimates for model 3: treatment specific variance")

# plot
# m3_int_table %>%
#   ggplot() +
#   geom_point(aes(x = treatment, y = est.)) + 
#   geom_errorbar(aes(x = treatment, ymin = lower, ymax = upper)) +
#   facet_wrap(~parameter) +
#   labs(title = "Parameter estimates for model 3: treatment specific variance",
#        y = "Estimate (95 % CI)",
#        x = "treatment (proportion peanut shell)")

```

Bean weevil opulation growth rate (a) decreased as food quality decreased (peanut shell increased). Density dependence was stronger for the low food quality treatments compared to the 0 % peanut shell treatment. The standard deviation of the process noise for treatments with > 0 % peanut shell was roughly twice as large compared to the process noise for the 0 % peanut shell treatment (table 2.).

## Goodness of fit for top model

```{r get_parms}
# extract parameter estimates from top model
parm_est <- tidy(m3) %>% add_column(ftreatment = as.factor(c(0,0,0.05,0.1,0.15,0.05,0.1,0.15)),
                                 parameter = c(c("b","a"),c("a","a","a"),c("b","b","b")) ) %>%
  select(parameter, ftreatment, estimate) %>%
  pivot_wider(names_from = parameter, values_from = estimate)

# replicate parm_est 10 times (# of replicates) so that I can join it to other dfs
#parm_est <- purrr::map_dfr(seq_len(10), function(x) parm_est) 

# get initial log population sizes for all pops
# and join to var_est
init_pop <-
  weevil %>%
  group_by(ftreatment, replicate) %>% 
  mutate(tfinal = (last(days) - first(days)) / 4) %>% # divide by 4 because weevils were counted every 4 days
  filter(days == first(days)) %>%
  group_by(ftreatment) %>%
  select(ftreatment, replicate, l_total, tfinal) %>% 
  full_join(var_est_trt, by = "ftreatment")

# data frame with all initial value and parms for simulations
init_df <- inner_join(init_pop, parm_est)
```

### Predicted carrying capacity vs. mean observed population abundances

```{r calc_K}
nobs <- weevil %>% filter(!is.na(l_total),!is.na(l_next_total)) %>% group_by(treatment) %>% summarize(nobs = n()) %>% 
  rename(ftreatment = treatment) %>% mutate(ftreatment = as.factor(ftreatment))

K_m3 <- parm_est %>% inner_join(nobs) %>% inner_join(var_est_trt) %>%
  # compute mean and var of log-population and 95 % CI
  mutate(mean_logK = a/(1-b),
         trt_var = trt_resid^2,
         var_logK = trt_var/(1-b),
         upr_logK = mean_logK + 1.96*sqrt(var_logK),
         lwr_logK = mean_logK - 1.96*sqrt(var_logK),
         mean_logK_lwr = mean_logK - 1.96*sqrt(var_logK/(nobs - df_m3)),
         mean_logK_upr = mean_logK + 1.96*sqrt(var_logK/(nobs - df_m3))) %>%
  # compute mean and var of original scale population         
  mutate(log_mean_K = mean_logK + var_logK/2,
         mean_K = exp(log_mean_K),
         median_k = exp(mean_logK)) %>%
  # compute 95 % CI
  mutate(se_K = sqrt(trt_var/nobs + (trt_var^2 / 2* (nobs - 1)) ), # cox's method
         log_mean_K_lwr = log_mean_K - 1.96 * se_K,
         mean_K_lwr = exp(log_mean_K_lwr),
         log_mean_K_upr = log_mean_K + 1.96 * se_K,
         mean_K_upr = exp(log_mean_K_upr))

# calculate log of mean inital population size
log_mean_init <-
  weevil %>%
  group_by(treatment, replicate) %>%
  filter(days == first(days)) %>%
  ungroup() %>%
  transmute(init = mean(total),
         init = log(init)) %>%
  slice(1) %>% pull(init)

# compute mean log(n + 1) for each population
# would expect value for cycling pops to be biased high
mean_log_weevil <- weevil %>% group_by(ftreatment, freplicate) %>%
  # mutate(last_day = ifelse(is.na(last_day), Inf, last_day)) %>%
  # filter(days <= last_day) %>%
  mutate(l_total = ifelse(is.na(l_total), log(1), l_total)) %>%
  summarise(mean_l_total = mean(l_total, na.rm = TRUE))

K_m3 %>%
  ggplot(aes(x = ftreatment)) +
  geom_point(aes(y = mean_logK), size = 2) +
  geom_errorbar(aes(ymin = mean_logK_lwr, ymax = mean_logK_upr), width = 0.5) +
  geom_errorbar(aes(ymin = lwr_logK, ymax = upr_logK), col = "red", width = 0) +
  geom_hline(yintercept = log(1), linetype = 2, size = 1.5) +
  geom_hline(yintercept = log_mean_init, size = 1.5) +
  geom_jitter(data = mean_log_weevil, mapping = aes(y = mean_l_total, col = freplicate),size = 2, alpha = 0.5) +
  labs(title = "Estimated log carrying capacity",
       subtitle = "colored points are means of ln(N + 1) over total duration of experiment",
       caption = "red lines denote 95 % PI\ndashed line is extinction threshold (ln(1))\nsolid line is log of mean initial population",
       x = "proportion peanut shell",
       y = "Log Carrying capacity (95 % CI)") +
  theme(legend.position = "n")
```

The model prediction and experimental observations were compared on the $\ln(\text{abundance} + 1)$ scale. For the 0 % peanut shell treatment, the model predicted that the expected carrying capacity would be larger than the average initial population size, whereas the model predicts for all other treatment levels that the carrying capacity would be lower and that the extinction threshold was within the middle 95 % probability density of the carrying capacity distribution (which is normal on the log-scale cf. @dennis_estimating_2006). The observed data were within two standard deviations of the expected carrying capacity for populations in treatment levels 0, 10, and 15 % but exceeded the upper limit of the interval for populations under the 5 % treatment for which there were large transient oscillations in population abundance. Note, for interpretative purposes that comparing the predicted carrying capacity to the observed data may not be appropriate since the observed populations may not have yet reached their equilibrial dyanamics during the population experiments which can explain the systematic deviations for the 5 % treatment populations.

### 95 % prediction interval and observed population trajectories

```{r}
sims_small <- lapply(1:nrow(init_df), function(x)
  sim_log_gomp(xinit = unlist(init_df[x, "l_total"]), 
             lambda = unlist(init_df[x, "a"]), 
             b = unlist(init_df[x,"b"]), 
             sd_proc = unlist(init_df[x,"trt_resid"]), 
             tfinal = unlist(init_df[x,"tfinal"]), 
             nsim = 1,
             replicate = unlist(init_df[x,"replicate"]),
             ftreatment = unlist(init_df[x,"ftreatment"]))
  ) %>%
  bind_rows()

sims_small <- sims_small %>% mutate(N = N - 1) # correct for log(n + 1) transformation

# sims_small %>% unite("rep_sim",c("replicate", "sim"), remove = FALSE) %>%
#   ggplot() +
#   geom_line(aes(x = time*4 - 3, y = N, group = rep_sim), col = "red", alpha = 0.5) +
#   geom_line(data = weevil, mapping = aes(x = days - 32, y = total, group = replicate), alpha = 0.7) +
#   facet_wrap(~ftreatment) +
#   labs(title = "Gompertz model simulations with parameters from top model",
#        y = "Abundance of adult bean weevil",
#          x = "Days since beginning of treatment",
#        caption = "1 simulation per replicate.\nSimulations conditioned on inital population size in each replicate.")
```

```{r compute_95PI, cache = TRUE}
nsims <- 200
sims <- lapply(1:nrow(init_df), function(x)
  sim_log_gomp(xinit = unlist(init_df[x, "l_total"]), 
             lambda = unlist(init_df[x, "a"]), 
             b = unlist(init_df[x,"b"]), 
             sd_proc = unlist(init_df[x,"trt_resid"]), 
             tfinal = unlist(init_df[x,"tfinal"]), 
             nsim = nsims,
             replicate = unlist(init_df[x,"replicate"]),
             ftreatment = unlist(init_df[x,"ftreatment"]))
  ) %>%
  bind_rows(.id = "id") %>% mutate(N = N - 1)

# calculate 95 % prediction intervals
# average over replicate and simulation (don't group by it)
sim_interval <- sims %>% 
  mutate(time = time*4 - 3) %>% # transform to daily scale
  group_by(ftreatment, time) %>%
  summarise(mean_N = mean(N),
            p50 = median(N),
            p5 = quantile(N, 0.05),
            p95 = quantile(N, 0.95))
```

```{r trajectory_plot_interval}
sim_interval %>%
  ggplot() +
  geom_ribbon(aes(x = time, ymin = p5, ymax = p95), alpha = 0.3, fill = "red") + 
  # geom_line(aes(x = time, y = mean_N), alpha = 0.5, size = 2) +
  geom_line(aes(x = time, y = p50), size = 2, linetype = 2) +
  geom_line(data = weevil, mapping = aes(x = days - 32, # backshift by days spent initializing population
                                         y = total, group = replicate), alpha = 0.5) +
  facet_wrap(~ftreatment) +
  labs(y = "Adult weevil abundance (95 % prediction interval)",
       x = "time since treatment (days)",
       caption = "Dashed line denotes median prediction")
```

The 95 % prediction intervals for the top model cover most of the observed population abundances over time for the 0 % shell treatment. However, the 95 % PI has very low coverage of the observed population abundances beyond the initial decline observed across all the low quality food treatments. See Appendix section A4 for plots showing individual populations and predictions.

### Predicted and observed extinction frequency and distribution and mean of extinction time

```{r obs_extinction_time}
# get mean time to extinction and proportion of populations that went extinct
obs_ext_df <- weevil %>%
  group_by(treatment, replicate) %>%
  slice(1) %>%
  summarise(last_day) %>%
  group_by(treatment) %>%
  mutate(mean_time = mean(last_day, na.rm = TRUE),
         prop_extinct = sum(!is.na(last_day))/n(),
         ftreatment = as.factor(treatment)) %>%
  select(-treatment)

# ggplot() +
#   geom_histogram(data = obs_ext_df, mapping = aes(x = last_day)) +
#   geom_vline(data = obs_ext_df, mapping = aes(xintercept = mean_time), size = 1.5, linetype = 2) +
#   facet_wrap(~ftreatment) +
#   labs(title = "Distribution of observed extinction times")
```

```{r}
# ext_df <- 
#   sims %>% unite("sim_id", id, sim) %>%
#   group_by(ftreatment, sim_id, replicate) %>%
#   mutate(zeros = cumsum(N <= 0)) %>%
#   group_by(sim_id) %>%
#   mutate(went_extinct = sum(zeros > 0)) %>%
#   summarize(extinction_day = ifelse(zeros == 1, time*4 - 3, NA),
#             went_extinct) %>%
#   select(extinction_day, went_extinct) %>%
#   slice(1)

ext_df <- sims %>% unite("sim_id", id, sim) %>%
  group_by(ftreatment, sim_id) %>%
  mutate(zeros = cumsum(N <= 0)) %>%
  mutate(extinction_time = ifelse(zeros == 1, time, NA),
         extinction_time = min(extinction_time, na.rm = TRUE),
         extinction_time = ifelse(extinction_time == Inf, NA, extinction_time),
         extinction_time = extinction_time * 4 - 3)

ext_mean_df <- ext_df %>%
  group_by(ftreatment) %>%
  summarize(mean_extinction_day = mean(extinction_time, na.rm = TRUE))
            # num_extinct = n(!is.na(extinction_day)),
            # prop_extinct = num_extinct / nsims)

ggplot() +
  geom_density(data = ext_df, mapping = aes(x = extinction_time), fill = "red", alpha = 0.5, adjust = 3, col = "red") +  
  geom_density(data = obs_ext_df, mapping = aes(x = last_day), fill = "blue", alpha = 0.5, col = "blue") +
  geom_rug(data = obs_ext_df, mapping = aes(x = last_day), col = "blue") +
  geom_vline(data = ext_mean_df, mapping = aes(xintercept = mean_extinction_day), size = 1.5, col = "red") +
  geom_vline(data = obs_ext_df, mapping = aes(xintercept = mean_time), size = 1.5, col = "blue") +
  facet_wrap(~ftreatment) +
  labs(title = "Distribution of predicted and observed extinction times",
       x = "day of extinction",
       caption = "rug lines represent extinction time of specific populations")
```

No populations in the 0 % peanut shell treatment were predicted or observed to go extinct. All populations in other treatments were predicted to go extinct and these extinction time predictions were systematically biased low compared to the observed extinction times by one order of magnitude (table 3.). While only 2 out of the the 10 replicate populations for the 5 % shell treatment were observed to go extinct, all simulations resulted in extinction for this treatment level.

```{r compare_obs_pred_ext}
# calc number of runs for each treatment
sims_per_trt <- nsims * 10
# get the proportion of runs that went extinct per treatment
pred_prop_ext <- sims %>% unite("sim_id", id, sim) %>%
  group_by(sim_id) %>%
  mutate(zeros = sum(N <= 0) > 0) %>%
  slice(1) %>%
  group_by(ftreatment) %>%
  summarize(went_extinct = sum(zeros),
            prop_extinct = went_extinct / sims_per_trt) %>%
  select(treatment = ftreatment, `pred. prop. extinct` = prop_extinct)
# get the mean time to extinction
pred_MTE <- 
  ext_mean_df %>%
  rename(treatment = ftreatment, `pred. MTE` = mean_extinction_day)
# combine predicted MTE and prop extinct
pred_ext_summary <- full_join(pred_MTE, pred_prop_ext)

# format observed time to extinction
obs_ext_summary <- obs_ext_df %>% group_by(ftreatment) %>% slice(1) %>%
  select(treatment = ftreatment, "obs. MTE" = mean_time, "obs. prop. extinct" = prop_extinct)

# combine and report table
options(knitr.kable.NA = '-')
full_join(pred_ext_summary, obs_ext_summary) %>%
  select(1,2,4,3,5) %>%
  knitr::kable(caption = "Comparison of model predictions and observed population extinction")
```

# Discussion

Population dynamics and extinction are driven by both deterministic and stochastic effects. 
Confrontation of ecological models representing different hypotheses to population dynamics of bean weevils indicates that food limitation may have both deterministic and stochastic effects on population dynamics. 
However, the precending analysis is not a strong affirmation or rejection since the best fitted model was only capable of reproducing the features of the non-resource limited populations. 
The strong periodicity of the food-limited populations is not possible under the direct-density dependence Gompertz model which was fitted to these data. 
Therefore, consideration of models capable of producing cyclical dynamics would be more appropriate for these data and would facilitate stronger tests of hypotheses about the deterministic and stochastic impacts of food-limitation on population dynamics.

Future work could consider models that include delayed-density dependence or additional population lags. Models with delayed density dependence can produce cycles qualitatively similar to those observed in the weevil data and have been previously shown to provide a good fit to similar experimental populations (Nicholson's blowfly food-limitation experiments @wood_statistical_2010). Delayed density dependence would be a biologically justifiable assumption since egg laying decisions and larval success are density dependent and bean weevils development time ranges from a 20 - 60 days depending on food-quality (M. Dyck, unpublished). Models with additional population lags may be justified since not all stages of the weevil population are observed. Including lags of a univariate population time series as covariates can be used to account for the effect unobserved stages [@turchin_complex_2003].

\newpage

# References {-}

<div id="refs"></div>

\newpage

# Appendix

## A1. Fit of model on $log(x+1)$ scale

```{r lin_reg_plot}
# can I get CI for gls plot?
# adapt this code: http://bbolker.github.io/mixedmodels-misc/glmmFAQ.html#glmmadmb
nd <- expand_grid(l_total = seq(min(weevil$l_total, na.rm = T), max(weevil$l_total, na.rm = T), length.out = 100),
            ftreatment = unique(weevil$ftreatment))

## design matrix (fixed effects)
mm <- model.matrix(delete.response(terms(m3)),nd)
## calculate predicted values
nd$l_next_total <- drop(mm %*% coef(m3))

predvar <- diag(mm %*% vcov(m3) %*% t(mm))
nd$SE <- sqrt(predvar)

# ggplot(weevil) +
#   geom_point(aes(x = l_total, y = l_next_total))

nd %>%
  ggplot() +
  geom_line(aes(x = l_total, y = l_next_total), size = 1) +
  geom_ribbon(aes(x = l_total, ymin = l_next_total - 2*SE, ymax = l_next_total + 2 * SE), alpha = 0.5) +
  geom_point(data = weevil, mapping = aes(x = l_total, y = l_next_total, col = freplicate), alpha = 0.2) +
  facet_wrap(~ftreatment) +
  theme(legend.position = "n") +
  labs(title = "Top model prediction",y = "Next log(abundance)",
       x = "Current log(abundance)")

```

Here is the model predictions on the scale at which the model was fit. The model captures the mean behavior of the data relatively well across treatments. However, the error is larger for smaller observed  $\log(\text{abundance} + 1)$. Because of the transformation used the errors are also strongly non-normal at small values since the response is constrained to be $\geq 0$. 

```{r eval = FALSE}
# prediction plot using fitted points from augment.gls
m3_aug %>%
  ggplot() +
  geom_point(aes(x = l_total, y = l_next_total, col = freplicate), alpha = 0.5) +
  geom_line(aes(x = l_total, y = fitted), size = 2) +
  facet_wrap(~ftreatment) +
  theme(legend.position = "n") +
  labs(title = "Top model prediction",y = "Next log(abundance)",
       x = "Current log(abundance)")
```

## A2. Diagnostic plots for model 3

```{r resid_plot}
m3_aug %>%
  ggplot(aes(x = fitted, y = residuals)) +
  geom_jitter(aes(col = freplicate), alpha = 0.3, size = 2) +
  geom_smooth() +
  geom_hline(yintercept = 0, linetype = 2) +
  facet_wrap(~ftreatment) +
  labs(title = "Residual vs fitted plot: model 3") +
  theme(legend.position = "n")

```
The residual plots show that the models capture the expected value of the response (on $log(x+1)$ scale) since the expected value of the residual error is zero. However, there is a clear increase in the residual variance for smaller fitted values. This can be attributed to the tendancy of the weevil populations to crash to zero for a few time steps then increase suddenly due to the dynamics of weevil stage structure. This can be observed in the time series of the weevil abundances on the original scale. 

```{r loc_scale_plot}
m3_aug %>%
  group_by(ftreatment) %>%
  mutate(std_resid = residuals/sd(residuals),
         sqrt_abs_resid = sqrt(abs(std_resid))) %>%
  ggplot(aes(x = fitted, y = sqrt_abs_resid)) +
  geom_point(aes(col = freplicate), alpha = 0.5) +
  geom_smooth() +
  geom_hline(yintercept = 0.822, linetype = 2) + facet_wrap(~ftreatment) +
  labs(title = "Location-scale plot: model 3",
      x = "Fitted",
      y = "sqrt(abs(std.resid))",
      col = "Treatment") +
  theme(legend.position = "n")
```
These plots demonstrate that the residuals are not homogeneous for the 5 % and 10 % treatments.

```{r qq_plot}
# qqline
y <- quantile(m3$residuals, c(0.25, 0.75))
x <- qnorm(c(0.25, 0.75))
slope <- diff(y)/diff(x)
int <- y[1L] - slope * x[1L]

ggplot(m3_aug, aes(sample = residuals)) + stat_qq() + geom_abline(slope = slope, 
    intercept = int) + facet_wrap(~ftreatment) + 
  labs(title = "QQ plots")
```
The residuals for 0 % peanut shell are reasonably normal. There are strong departures from normality (heavy-tails) for treatments 5 - 15 %. This implies that confidence intervals computed assuming normal residuals will be too narrow.

## A3. Residuals vs. time

```{r resid_time, out.width="50%", fig.show="hold"}
m3_aug %>%
  filter(ftreatment == 0) %>%
  ggplot(aes(x = days, y = residuals)) +
  geom_point(alpha = 0.5) +
  geom_line(alpha = 0.5) +
  # geom_smooth() +
  geom_hline(yintercept = 0, linetype = 2) +
  facet_wrap(~replicate) +
  labs(title = "0 % shell")

m3_aug %>%
  filter(ftreatment == 0.05) %>%
  ggplot(aes(x = days, y = residuals)) +
  geom_point(alpha = 0.5) +
  geom_line(alpha = 0.5) +
  # geom_smooth() +
  geom_hline(yintercept = 0, linetype = 2) +
  facet_wrap(~replicate) +
  labs(title = "5 % shell")
```
There are no obvious temporal patterns in the residuals for 0 % shell. These is some evidence of cycling evident in the 5 % shell treatment that was not captured by the model (i.e., replicates 2, 6, and 8)


```{r trt_3_4, out.width="50%", fig.show="hold"}
m3_aug %>%
  filter(ftreatment == 0.1) %>%
  ggplot(aes(x = days, y = residuals)) +
  geom_point(alpha = 0.5) + 
  geom_line(alpha = 0.5) +
  #geom_smooth() +
  geom_hline(yintercept = 0, linetype = 2) +
  facet_wrap(~replicate) +
  labs(title = "10 % shell")

m3_aug %>%
  filter(ftreatment == 0.15) %>%
  ggplot(aes(x = days, y = residuals)) +
  geom_point(alpha = 0.5) + 
  geom_line(alpha = 0.5) +
  #geom_smooth() +
  geom_hline(yintercept = 0, linetype = 2) +
  facet_wrap(~replicate) +
  labs(title = "15 % shell")
```
There is obvious periodicity present in the residual vs time plots for the 10 % and 15 % peanut shell treatments.

## A4. Population level prediction plots
The following simulations are only conditioned on the initial population size one treatment starts (day 32). That is, the model is not conditioned on the current data point at each prediction.

```{r}
filter(sims_small, ftreatment == 0) %>%
  ggplot() +
  geom_line(aes(x = time*4, y = N, group = interaction(replicate,sim) ), col = "red", alpha = 0.5) +
  geom_line(data = filter(weevil, ftreatment == 0), mapping = aes(x = days - 32, y = total, group = replicate)) +
  facet_wrap(~replicate) +
   labs(title = "Gompertz model simulations with parameters from top model",
       y = "Abundance of adult bean weevil",
       subtitle = "0 % peanut shell",
         x = "Days since beginning of treatment",
       caption = "1 simulation per replicate.\nSimulations conditioned on inital population size in each replicate.")


```

```{r}
filter(sims_small, ftreatment == 0.05) %>%
  ggplot() +
  geom_line(aes(x = time*4, y = N, group = interaction(replicate,sim) ), col = "red", alpha = 0.5) +
  geom_line(data = filter(weevil, ftreatment == 0.05), mapping = aes(x = days - 32, y = total, group = replicate)) +
  facet_wrap(~replicate) +
   labs(title = "Gompertz model simulations with parameters from top model",
        subtitle = "5 % peanut shell",
       y = "Abundance of adult bean weevil",
         x = "Days since beginning of treatment",
       caption = "1 simulation per replicate.\nSimulations conditioned on inital population size in each replicate.")
```

```{r}
filter(sims_small, ftreatment == 0.1) %>%
  ggplot() +
  geom_line(aes(x = time*4, y = N, group = interaction(replicate,sim) ), col = "red", alpha = 0.5) +
  geom_line(data = filter(weevil, ftreatment == 0.1), mapping = aes(x = days - 32, y = total, group = replicate)) +
  facet_wrap(~replicate) +
   labs(title = "Gompertz model simulations with parameters from top model",
        subtitle = "10 % peanut shell",
       y = "Abundance of adult bean weevil",
         x = "Days since beginning of treatment",
       caption = "1 simulation per replicate.\nSimulations conditioned on inital population size in each replicate.")

```

```{r}
filter(sims_small, ftreatment == 0.15) %>%
  ggplot() +
  geom_line(aes(x = time*4, y = N, group = interaction(replicate,sim) ), col = "red", alpha = 0.5) +
  geom_line(data = filter(weevil, ftreatment == 0.15), mapping = aes(x = days - 32, y = total, group = replicate)) +
  facet_wrap(~replicate) +
   labs(title = "Gompertz model simulations with parameters from top model",
       y = "Abundance of adult bean weevil",
       subtitle = "15 % peanut shell",
         x = "Days since beginning of treatment",
       caption = "1 simulation per replicate.\nSimulations conditioned on inital population size in each replicate.")
```
