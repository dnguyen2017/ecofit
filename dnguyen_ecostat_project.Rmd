---
title: "Deterministic and stochastic effects of food quality on extinction time"
author: "David Nguyen"
date: "October 20, 2020"
output: 
  html_document:
    code_folding: hide
# output:
#   word_document: default
bibliography: nres803.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
library(tidyverse)
library(readxl)
library(broom.mixed)
library(nlme)
```

```{r munge_data, include = FALSE}
# get names of sheets that contain pop data (not including T15-8 for now)
sheet_names <- excel_sheets("weevil_data/pop_dynamics_expt_data.xlsx")
sheet_pops <- sheet_names[1:5]
pct_peanut_shells <- c(0, 0.03, 0.05, 0.10, 0.15)

# create new colnames
npop <- 10
date_cols <- c("days", "date")
demo_cols <- unlist(lapply(1:npop,
       function(i)
         c(paste0("m_alive_",i),
           paste0("f_alive_",i),
           paste0("total_alive_", i),
           paste0("m_dead_",i),
           paste0("f_dead_",i),
           paste0("total_dead_",i))))
treatment_cols <- c("m_added", "f_added", "pellets", "noclue", "treatment")

# read-in and reformat all population data sheets

list_dfs <- vector("list", length = length(sheet_pops)) # init list to store each df

# loop to read and reformat
for (i in seq_along(sheet_pops)) {
  df_now <-
    read_excel("weevil_data/pop_dynamics_expt_data.xlsx",
               skip = 3,
               sheet = sheet_pops[i]) %>%
    mutate(treatment = pct_peanut_shells[i])
  
  # assign new colnames
  names(df_now) <-
    c(date_cols, demo_cols, treatment_cols) # should include check to make sure all data sheets have same format
  
  # T15 has weird ??? in a col. CHange to NA and convert col to numeric
  if (i == 5) {
    df_now$m_alive_8 <-
      df_now %>% 
      mutate_at(vars('m_alive_8'), ~na_if(., '???')) %>%
      pull(m_alive_8) %>%
      as.numeric()
  }
  
  # make data longer for plotting
  df_long <- df_now %>%
    select(-pellets,-noclue) %>% # always 2 pellets a day, and drop noclue as well as the num. added
    filter(!is.na(days)) %>%  # drop empty bottom two rows (included when reading due to sum(pellets) in spread sheet)
    pivot_longer(
      -c(days, date, m_added, f_added,treatment),
      names_sep = "_",
      names_to = c("sex", "status", "replicate"),
      values_to = "count"
    ) %>%
    # original data file did not have totals computed for all days
    # create new df with totals for all days
    filter(sex != "total" , status == "alive") %>%
    group_by(date, replicate) %>%
    mutate(total = sum(count, na.rm = TRUE)) %>% # females were not observed after first few days
    ungroup()
  
  # save to list
  list_dfs[[i]] <- df_long
}

full_df <- bind_rows(list_dfs)

full_df <- full_df %>% mutate(replicate = as.numeric(replicate))
#full_df$treatment <- as_factor(full_df$treatment) # for proper facetting when plotting. Should convert to numeric instead.
```

```{r clean_for_analysis, warning = FALSE}
# verify that "total" is the same regardless of sex (which wasn't actually distinguished during expt)
# all.equal( filter(full_df, sex == "m") %>% pull(total), filter(full_df, sex == "f") %>% pull(total) )
weevil <-
  full_df %>%
  filter(sex == "m",  # remove duplicate rows of "total"
         is.na(m_added)) %>% # Only include data after initialization complete
  select(days, treatment, replicate, total) %>% # drop all unimportant cols
  filter(treatment != 0.03) # drop 3 % shell treatment, since it is diff length and was only initialized 20 days instead of 32 like others

# set all "total" values to NA after extinction
# I will define exinction as the last time the cumulative population total increases
# e.g., take cumsum for all trt X rep combinations, then get index where cumsum(total) == max(cumsum), set all total values afterwards to NA

weevil <- 
  weevil %>% 
  group_by(treatment, replicate) %>%
  mutate(cumtotal = cumsum(total), 
         max_cumtotal = max(cumtotal)) %>%
  rowwise() %>%
  mutate(last_day = ifelse( (cumtotal == max_cumtotal) && (total == 0), days, NA)) %>%
  group_by(treatment, replicate) %>%
  mutate(last_day = min(last_day, na.rm = TRUE)) %>%
  mutate(total = ifelse(days > last_day, NA, total)) %>%
  mutate(last_day = ifelse(last_day == Inf, NA, last_day)) %>%
  # get next total, ln(abundance + 1), compute r, and make a new treatment col that is a factor
  mutate(next_total = lead(total),
         l_total = log(total + 1),
         l_next_total = log(next_total + 1),
         r = log((next_total + 1)/(total + 1)),
         ftreatment = factor(treatment, levels = c("0", "0.05", "0.1", "0.15")),
         freplicate = factor(replicate, levels = as.character(1:10)),
         time = (days - 32)/4) %>%
  unite(c("ftreatment", "replicate"), col = "rep_trt", remove = FALSE)
```

```{r define_sim_gomp}
sim_log_gomp <- function (xinit,     # initial log population size
                     lambda, # population growth rate,
                     b,      # density dependence
                     sd_proc, # process noise: N(0, sd_proc)
                     tfinal,
                     nsim,
                     replicate,
                     ftreatment) {
  
  # init storage list for all simulation
  sim_list <- vector("list", length = nsim)
  
  for (i in seq_along(sim_list)) {
    # init storage for current simulation
    log_x <- vector("numeric", length = tfinal)
    log_x[1] <- xinit
    
    # sim population dynamics
    for (j in 2:tfinal) {
      proc_error <- rnorm(n = 1, mean = 0, sd = sd_proc)
      log_x[j] <- lambda + b * log_x[j-1] + proc_error
    }
    # save current simulation
    sim_list[[i]] <- (tidyr::tibble(time = 1:tfinal,
                                    log_x = log_x,
                                    N = exp(log_x),
                                    lambda = lambda,
                                    b_ = b,
                                    sd_proc = sd_proc,
                                    replicate = replicate,
                                    ftreatment = ftreatment))
  } 
  out <- dplyr::bind_rows(sim_list, .id = "sim")
  return(out)
}
```

# Introduction

Habitat degredation a major threat to animal populations [@sala_global_2000]. As a consequence, food quality may also be reduced which are known to have strong impacts on individual and population level growth [@awmack_host_2002; @griffen_effects_2008]. Poor food quality typically decrease fecundity and increase development time which may, in turn, reduce population level growth rates and carrying capacity. In experimental studies, the effects of food quality on population parameters are quantified by including food quality as a covariate for estimating population parameters; however, to the best of my knowledge, the effect of food quality on the variability of population parameters is not routinely quantified despite clear signals of food-quality specific variability in experimental data [cf. figure 2 in @griffen_effects_2008].

Both deterministic and stochastic forces drive population dynamics and extinction risk [@bjornstad_noisy_2001; @fung_partitioning_2019]. For example, low population growth rates are a deterministic driver of population declines whereas variability in population growth rates is a stochastic driver of increased extinction risk [@vucetich_population_2000]. Appropriately modeling the sources of stochasticity is important for accurate modeling of population dynamics and extinction risk [@melbourne_extinction_2008]. Therefore, when modeling the effect of a food quality on population growth it may be important to consider both fixed and random effects for accurate assessments of extinction risk.

The main objective of this analysis is to identify the relative contributions of the deterministic and stochastic impact of resource quality on extinction time. Food quality may impact populations deterministically by affecting population growth rate and/or carrying capacity and stochastically by increasing variability of environmental noise. I will use existing time-series data of southern cowpea weevil (*Callosobruchus maculatus*) populations subjected to food quality treatments (M. Dyck unpublished). To quantify the contribution of deterministic and stochastic effects of food quality, I will fit a set of population models to the bean weevil data that allow for:

1. Growth rate and density dependence to vary with food quality;
2. An additive effect of food quality on environmental noise;
3. Both 1 and 2.

The models will be compared by AIC and goodness of fit will be assessed by comparing the extinction frequency and extinction time distribution of the observed weevil populations and simulations from fitted models. 

# Materials and methods

### Bean weevil population data

```{r plot_all, eval = FALSE}
full_df %>%
  filter(treatment != 0.03) %>%
  ggplot(aes(x = days, y = total, group = replicate, col = as.factor(replicate) )) +
  geom_line() + 
  facet_wrap(~treatment) +
  theme_light() +
  theme(legend.position = "none") +
  scale_x_continuous(breaks = seq(0, 650, by = 100)) +
  scale_y_continuous(breaks = seq(0, 50, by = 10)) +
  labs(title = "Bean weevil populations over time",
       caption = "For each plot, weevils were fed pellets with a different proportion of peanut shell additive.\nEach color is a different replicate.",
       y = "Bean weevil count",
       x = "Time (days)")

```

The quality of food provided to the weevils was experimentally manipulated by manufacturing artificial bean pellets made from ground black-eyed pea powder and varying percentages of powdered peanut shells (0, 3, 5, 10, and 15 %). Larger percentages of peanut shell simulate lower food quality.  To initialize each replicate population, two males and two females were added every four days for the first 28 days of the experiment. After this initialization, two fresh bean pellets were added weekly without any further addition of adults. There were 10 replicate populations allocated to each treatment resulting in a total of 50 population time-series. Populations were maintained until the populations crashed or were stopped after 632 days (the 3 % peanut shell treatment was started later and ran for 400 days). A complete census of adult bean weevils was conducted every four days.

### Model structure and fitting

The discrete-time stochastic Gompertz model will be fit to the remainder of weevil abundances after the initialization phase is removed. The Gompertz model is commonly used for modeling ecological populations [@dennis_estimating_2006]. The models will be estimated using a one-step fitting procedure which assumes that there is no observation noise [@bolker_ecological_2008]; this is an appropriate assumption since the populations were completely censused at each time point. 

The full model is as follows:

$$y_{t+1,i,j} = a_i + b_i y_t + c_i + d_j + \epsilon_{t,i,j} \\
\epsilon_{t,i,j} \sim N(0,\sigma_0^2)\\
c_i \sim N(0, \sigma_i^2)\\
d_{ij} \sim N(0, \sigma_{rep}^2)$$

Where $\ln(N_{t,i,j} + 1) = y_{t,i,j}$ is the log-population abundance at times $t$ for peanut shell percentages $i = 0, 3, 5, 10, 15$ and replicates $j = 1, \ldots, 10$. The deterministic (fixed-effect) of food quality operates on weevil populations are represented by the population growth rate ($a_i$) and the strength of density dependence ($b_i$). The stochastic (random-effect) of food quality on weevil populations are represented by a food-specific increase in variance of population growth ($c_i$) from time step $t$ to $t+1$. The random effect of replicate and random error are denoted $d_j$ and $epsilon_{t,i,j}$ respectively.

The model that includes only the deterministic impact of food quality is obtained by dropping the $c_i$ term. The model for only the stochastic impact of food quality is obtained by estimating a common population growth rate ($a$) and density dependence coefficient ($b$) across all food quality treatments.

<!-- A likely short-coming of the models I will fit is that the models only include the effect of the previous log-population abundance on the size of the next log-population abundance. However, the sampling frequency (every four days) is much shorter than the generation times of the weevils which range between 20 and 60 days depending on resource quality. A more careful analysis would involve assessing the number of lagged population sizes to capture the dynamics of the population data. -->
<!-- * assumes process noise only (ok because population are completely censused at each observation time; Ben Bolker book) -->
<!-- * higher-order lags can be collected into error term. Shaky assumption, especially considering that larvae and eggs are unobserved. A suitable approach would be to try using additional lagged terms which can be justified by Takens theorem (see ellner and turchin paper). -->

<!-- ### Model set -->

<!-- Full model -->

### Estimating carrying capacity

The expected log-abundance is $E(X_{\infty,i}) = a_i/(1-b_i)$, the variance of the stationary distribution of the log population is $V(X_{\infty,i}) = \sigma^2/(1-b_i)$, and the mean of the log-normal distribution of abundance is $E(N_{\infty,i}) = \exp[E(X_{\infty,i}) + V(X_{\infty,i})/2]$ [@dennis_estimating_2006].

### Evaluating goodness of fit

Assessing the goodness of fit for noisy populations is challenging because sensitivity to small changes in initial conditions and process noise may generate very different population trajectories [@wood_statistical_2010]. To avoid these issues, I will assess goodness of fit by comparing summary statistics of the observed data to the same summary statistics computed for simulated output from the fitted Gompertz models. For each fitted model, I will repeatedly simulate the model for the same number of time steps the experimental populations were observed and the same number of replicates used in the experiment. The summary statistics I will use are: (1) the frequency of populations that became extinct; (2) the distribution of time to extinction, conditioned on having observed extinctions.

<!-- Statistical probes  ala Simon Wood (2010) -->

<!-- * Use ar(1) and extinction time as statistical summaries -->
<!-- * maybe use rolling mean and variance too? -->

```{r plot_obs_extinction_time, eval = FALSE}
weevil %>%
  group_by(treatment, replicate) %>%
  slice(1) %>%
  summarise(last_day) %>%
  group_by(treatment) %>%
  mutate(mean_time = mean(last_day, na.rm = TRUE),
         treatment = as.factor(treatment)) %>%
  ggplot() +
  geom_histogram(aes(x = last_day, group = treatment)) +
  geom_vline(aes(xintercept = mean_time, group = treatment), size = 1.5, linetype = 2) +
  facet_wrap(~treatment) +
  labs(title = "Distribution of observed extinction times")
```

# Results

### Model comparison

```{r fit_models}
# treatment specific growth rate and density dependnece
# homogenous variance
m1 <- gls(l_next_total ~ l_total*ftreatment - 1, 
    data = weevil, 
    method = "ML",
    na.action=na.omit)

# common growth rate and density dependnece
# treatment specific variance
m2 <- 
  gls(l_next_total ~ l_total - 1, 
    data = weevil, 
    weights = varIdent(form = ~1 | ftreatment), # factor specific residual variance
    method = "ML",
    na.action=na.omit)

# treatment specific growth rate and density dependnece
# treatment specific variance
m3 <- 
  gls(l_next_total ~ l_total*ftreatment -1, 
    data = weevil, 
    weights = varIdent(form = ~1 | ftreatment), # factor specific residual variance
    method = "ML",
    na.action=na.omit)

# treatment specific growth rate and density dependnece
# treatment specific variance
# random intercept of rep:trt (which is replicate nested in treatment)
m4 <- lme(l_next_total ~ l_total*ftreatment - 1, 
    random = ~ 1 | rep_trt,
    data = weevil, 
    weights = varIdent(form = ~1 | ftreatment), # factor specific residual variance
    method = "ML",
    na.action=na.omit) # ignore na values

# treatment specific growth rate and density dependnece
# treatment specific variance
# random intercept and slope of rep:trt (which is replicate nested in treatment
# I'm not sure if this is specified correctly
# m5 <- lme(l_next_total ~ l_total*ftreatment - 1, 
    # random = ~ 1 + ftreatment| rep_trt,
    # data = weevil, 
    # weights = varIdent(form = ~1 | ftreatment), # factor specific residual variance
    # method = "ML",
    # na.action=na.omit) # ignore na values
```

```{r eval = FALSE}
m3_drop8 <- 
  gls(l_next_total ~ l_total*ftreatment -1, 
    data = weevil %>% filter(!(ftreatment == 0.15 & replicate == 8)), 
    weights = varIdent(form = ~1 | ftreatment), # factor specific residual variance
    method = "ML",
    na.action=na.omit)

summary(m3_drop8)
```


```{r aic_table}
AIC(m1, m2, m3, m4) %>%
  mutate(delta = AIC - min(AIC),
         weight = exp(-delta/2),
         weight = weight/sum(weight)) %>%
  add_column(model = c("model 1", "model 2", "model 3", "model 4")) %>%
  add_column(`log likelihood` = c(m1$logLik, m2$logLik, m3$logLik, m4$logLik)) %>%
  select(model,`log likelihood`, df, AIC, delta, weight) %>%
  knitr::kable(digits = 3)
```

```{r AIC_5, eval = FALSE}
AIC(m1, m2, m3, m4, m5) %>%
  mutate(delta = AIC - min(AIC),
         weight = exp(-delta/2),
         weight = weight/sum(weight)) %>%
  add_column(model = c("model 1", "model 2", "model 3", "model 4", "model 5")) %>%
  select(model, df, AIC, delta, weight) %>%
  knitr::kable(digits = 3)
```

```{r augment_m3}
m3_aug <- 
  augment(m3, weevil) %>%
  rename(residuals = .resid, fitted = .fitted)
```


```{r eval = FALSE}
# get coef from m4
coef(m4) %>%
  as_tibble(rownames = "treatment_replicate") %>%
  separate(treatment_replicate, sep = "_", into = c("treatment", "replicate"))
```


```{r get_m3_trt_sd}
# try to calculate factor-specific residual SE
df_m3 <- 12 # residual df (I think??? Not sure how this works with factor specific var) 

var_est_trt <- m3_aug %>%
  group_by(ftreatment) %>%
  mutate(sd_resid = sd(residuals), # directly calculate sd ### this is wrong!!!!
         sq_resid = sum(residuals^2),
         nobs = n()) %>%
  # this is the correct sd!
  mutate(se_resid = sqrt(sq_resid/ (nobs - df_m3))) %>% # calculate sqrt(SSE/df_error)
  summarize(sd_resid, se_resid) %>%  
  slice(1) %>%
  select(ftreatment, trt_resid = se_resid)
```


```{r eval = FALSE}
# check for the largest jump in abundance
weevil %>% group_by(ftreatment, freplicate) %>% mutate(difference = l_next_total - l_total, max_diff = max(difference, na.rm = TRUE)) %>% filter(difference == max_diff) %>%
  group_by(ftreatment) %>%
  filter(difference == max(max_diff)) 
```

# Model 3 parameter estimates

```{r confidence_int}
# get CI for a and b estimates of model 3
m3_int <- intervals(m3)
m3_int_coef <- m3_int$coef %>%
  as_tibble(rownames = "coefficient") %>%
  mutate(parameter_sym = case_when(str_detect(coefficient, "l_total") ~ "b",
                                 str_detect(coefficient, "ftreatment") ~ "a",
                                 TRUE ~ coefficient),
         parameter = case_when(parameter_sym == "a" ~ "population growth rate (a)",
                               parameter_sym == "b" ~ "density dependence (b)")) %>%
  mutate(treatment = str_remove_all(coefficient, "[[:alpha:]|:|_]"), # keep only numbers and decimal point
         treatment = ifelse(treatment == "", "0", treatment),
         treatment = factor(treatment, levels = c("0", "0.05","0.1","0.15"))) %>%
  mutate(`estimate (95 % CI)` = paste(round(est.,2), " (", round(lower,2), ", ", round(upper,2), ")"))

# get trt specific sd
m3_int_sigma <- 
  m3_int$sigma %>%
  as_tibble(rownames = "estimate") %>%
  pivot_wider(names_from = "estimate", values_from = "value") %>%
  add_column(treatment = factor(0, levels = c("0", "0.05","0.1","0.15")))

m3_int_varStruct <- 
  m3_int$varStruct %>%
  as_tibble(rownames = "treatment") %>%
  mutate(treatment = factor(treatment, levels = c("0", "0.05","0.1","0.15")))

m3_int_sd <-  bind_rows(m3_int_sigma, m3_int_varStruct) %>%
  mutate(lower = ifelse(treatment != 0, lower*m3_int_sigma$lower, lower),
         est. = ifelse(treatment != 0, est. * m3_int_sigma$est., est.),
         upper = ifelse(treatment != 0, upper * m3_int_sigma$upper, upper)) %>%
  mutate(`estimate (95 % CI)` = paste(round(est.,2), " (", round(lower,2), ", ", round(upper,2), ")")) %>%
  mutate(parameter = "process noise (sd)")

# combine coef and sd tibbles
m3_int_table <- full_join(m3_int_coef, m3_int_sd)

# table
m3_int_table %>% select(treatment, parameter, `estimate (95 % CI)`) %>%
  pivot_wider(names_from = parameter, values_from = `estimate (95 % CI)`) %>%
  knitr::kable(caption = "Parameter estimates for model 3: treatment specific variance")

# plot
m3_int_table %>%
  ggplot() +
  geom_point(aes(x = treatment, y = est.)) + 
  geom_errorbar(aes(x = treatment, ymin = lower, ymax = upper)) +
  facet_wrap(~parameter) +
  labs(title = "Parameter estimates for model 3: treatment specific variance",
       y = "Estimate (95 % CI)",
       x = "treatment (proportion peanut shell)")

```

```{r get_parms}
# extract parameter estimates from top model
parm_est <- tidy(m3) %>% add_column(ftreatment = as.factor(c(0,0,0.05,0.1,0.15,0.05,0.1,0.15)),
                                 parameter = c(c("b","a"),c("a","a","a"),c("b","b","b")) ) %>%
  select(parameter, ftreatment, estimate) %>%
  pivot_wider(names_from = parameter, values_from = estimate)

# replicate parm_est 10 times (# of replicates) so that I can join it to other dfs
#parm_est <- purrr::map_dfr(seq_len(10), function(x) parm_est) 

# get initial log population sizes for all pops
# and join to var_est
init_pop <-
  weevil %>%
  group_by(ftreatment, replicate) %>% 
  mutate(tfinal = (last(days) - first(days)) / 4) %>% # divide by 4 because weevils were counted every 4 days
  filter(days == first(days)) %>%
  group_by(ftreatment) %>%
  select(ftreatment, replicate, l_total, tfinal) %>% 
  full_join(var_est_trt, by = "ftreatment")

# data frame with all initial value and parms for simulations
init_df <- inner_join(init_pop, parm_est)
```

# Predicted carrying capacity

```{r calc_K}
nobs <- weevil %>% filter(!is.na(l_total),!is.na(l_next_total)) %>% group_by(treatment) %>% summarize(nobs = n()) %>% 
  rename(ftreatment = treatment) %>% mutate(ftreatment = as.factor(ftreatment))

K_m3 <- parm_est %>% inner_join(nobs) %>% inner_join(var_est_trt) %>%
  # compute mean and var of log-population and 95 % CI
  mutate(mean_logK = a/(1-b),
         trt_var = trt_resid^2,
         var_logK = trt_var/(1-b),
         upr_logK = mean_logK + 1.96*sqrt(var_logK),
         lwr_logK = mean_logK - 1.96*sqrt(var_logK),
         mean_logK_lwr = mean_logK - 1.96*sqrt(var_logK/(nobs - df_m3)),
         mean_logK_upr = mean_logK + 1.96*sqrt(var_logK/(nobs - df_m3))) %>%
  # compute mean and var of original scale population         
  mutate(log_mean_K = mean_logK + var_logK/2,
         mean_K = exp(log_mean_K),
         median_k = exp(mean_logK)) %>%
  # compute 95 % CI
  mutate(se_K = sqrt(trt_var/nobs + (trt_var^2 / 2* (nobs - 1)) ), # cox's method
         log_mean_K_lwr = log_mean_K - 1.96 * se_K,
         mean_K_lwr = exp(log_mean_K_lwr),
         log_mean_K_upr = log_mean_K + 1.96 * se_K,
         mean_K_upr = exp(log_mean_K_upr))

# calculate log of mean inital population size
log_mean_init <-
  weevil %>%
  group_by(treatment, replicate) %>%
  filter(days == first(days)) %>%
  ungroup() %>%
  transmute(init = mean(total),
         init = log(init)) %>%
  slice(1) %>% pull(init)

# compute mean log(n + 1) for each population
# would expect value for cycling pops to be biased high
mean_log_weevil <- weevil %>% group_by(ftreatment, freplicate) %>%
  # mutate(last_day = ifelse(is.na(last_day), Inf, last_day)) %>%
  # filter(days <= last_day) %>%
  mutate(l_total = ifelse(is.na(l_total), log(1), l_total)) %>%
  summarise(mean_l_total = mean(l_total, na.rm = TRUE))

K_m3 %>%
  ggplot(aes(x = ftreatment)) +
  geom_point(aes(y = mean_logK), size = 2) +
  geom_errorbar(aes(ymin = mean_logK_lwr, ymax = mean_logK_upr), width = 0.5) +
  geom_errorbar(aes(ymin = lwr_logK, ymax = upr_logK), col = "red", width = 0) +
  geom_hline(yintercept = log(1), linetype = 2, size = 1.5) +
  geom_hline(yintercept = log_mean_init, size = 1.5) +
  geom_jitter(data = mean_log_weevil, mapping = aes(y = mean_l_total, col = freplicate),size = 2, alpha = 0.5) +
  labs(title = "Estimated log carrying capacity",
       subtitle = "colored points are means of ln(N + 1) over total duration of experiment",
       caption = "red lines denote 95 % PI\ndashed line is extinction threshold (ln(1))\nsolid line is log of mean initial population",
       x = "proportion peanut shell",
       y = "Log Carrying capacity (95 % CI)") +
  theme(legend.position = "n")
```


# simulations with estimated parameters

```{r}
sims_small <- lapply(1:nrow(init_df), function(x)
  sim_log_gomp(xinit = unlist(init_df[x, "l_total"]), 
             lambda = unlist(init_df[x, "a"]), 
             b = unlist(init_df[x,"b"]), 
             sd_proc = unlist(init_df[x,"trt_resid"]), 
             tfinal = unlist(init_df[x,"tfinal"]), 
             nsim = 1,
             replicate = unlist(init_df[x,"replicate"]),
             ftreatment = unlist(init_df[x,"ftreatment"]))
  ) %>%
  bind_rows()

sims_small <- sims_small %>% mutate(N = N - 1) # correct for log(n + 1) transformation

sims_small %>% unite("rep_sim",c("replicate", "sim"), remove = FALSE) %>%
  ggplot() +
  geom_line(aes(x = time*4 - 3, y = N, group = rep_sim), col = "red", alpha = 0.5) +
  geom_line(data = weevil, mapping = aes(x = days - 32, y = total, group = replicate), alpha = 0.7) +
  facet_wrap(~ftreatment) +
  labs(title = "Gompertz model simulations with parameters from top model",
       y = "Abundance of adult bean weevil",
         x = "Days since beginning of treatment",
       caption = "1 simulation per replicate.\nSimulations conditioned on inital population size in each replicate.")
```

```{r compute_95PI, cache = TRUE}
sims <- lapply(1:nrow(init_df), function(x)
  sim_log_gomp(xinit = unlist(init_df[x, "l_total"]), 
             lambda = unlist(init_df[x, "a"]), 
             b = unlist(init_df[x,"b"]), 
             sd_proc = unlist(init_df[x,"trt_resid"]), 
             tfinal = unlist(init_df[x,"tfinal"]), 
             nsim = 200,
             replicate = unlist(init_df[x,"replicate"]),
             ftreatment = unlist(init_df[x,"ftreatment"]))
  ) %>%
  bind_rows()

sims <- sims %>% mutate(N = N - 1)

# calculate 95 % prediction intervals
# average over replicate and simulation (don't group by it)
sim_interval <- sims %>% 
  mutate(time = time*4 - 3) %>% # transform to daily scale
  group_by(ftreatment, time) %>%
  summarise(mean_N = mean(N),
            p50 = median(N),
            p5 = quantile(N, 0.05),
            p95 = quantile(N, 0.95))
```

```{r trajectory_plot_interval}
sim_interval %>%
  ggplot() +
  geom_ribbon(aes(x = time, ymin = p5, ymax = p95), alpha = 0.3, fill = "red") + 
  geom_line(aes(x = time, y = mean_N), alpha = 0.5, size = 2) +
  geom_line(aes(x = time, y = p50), size = 2, linetype = 2) +
  geom_line(data = weevil, mapping = aes(x = days - 32, # backshift by days spent initializing population
                                         y = total, group = replicate), alpha = 0.5) +
  facet_wrap(~ftreatment)
```


# References {-}

<div id="refs"></div>

# Appendix

## Linear regression prediction plot

```{r lin_reg_plot}
# can I get CI for gls plot?
# adapt this code: http://bbolker.github.io/mixedmodels-misc/glmmFAQ.html#glmmadmb
nd <- expand_grid(l_total = seq(min(weevil$l_total, na.rm = T), max(weevil$l_total, na.rm = T), length.out = 100),
            ftreatment = unique(weevil$ftreatment))

## design matrix (fixed effects)
mm <- model.matrix(delete.response(terms(m3)),nd)
## calculate predicted values
nd$l_next_total <- drop(mm %*% coef(m3))

predvar <- diag(mm %*% vcov(m3) %*% t(mm))
nd$SE <- sqrt(predvar)

# ggplot(weevil) +
#   geom_point(aes(x = l_total, y = l_next_total))

nd %>%
  ggplot() +
  geom_line(aes(x = l_total, y = l_next_total), size = 1) +
  geom_ribbon(aes(x = l_total, ymin = l_next_total - 2*SE, ymax = l_next_total + 2 * SE), alpha = 0.5) +
  geom_point(data = weevil, mapping = aes(x = l_total, y = l_next_total, col = freplicate), alpha = 0.5) +
  facet_wrap(~ftreatment) +
  theme(legend.position = "n") +
  labs(title = "Top model prediction",y = "Next log(abundance)",
       x = "Current log(abundance)")

```

```{r eval = FALSE}
# prediction plot using fitted points from augment.gls
m3_aug %>%
  ggplot() +
  geom_point(aes(x = l_total, y = l_next_total, col = freplicate), alpha = 0.5) +
  geom_line(aes(x = l_total, y = fitted), size = 2) +
  facet_wrap(~ftreatment) +
  theme(legend.position = "n") +
  labs(title = "Top model prediction",y = "Next log(abundance)",
       x = "Current log(abundance)")
```

## Diagnostic plots for model 3

```{r}
m3_aug %>%
  ggplot(aes(x = fitted, y = residuals)) +
  geom_jitter(aes(col = freplicate), alpha = 0.3, size = 2) +
  geom_smooth() +
  geom_hline(yintercept = 0, linetype = 2) +
  facet_wrap(~ftreatment) +
  labs(title = "Residual vs fitted plot: model 3") +
  theme(legend.position = "n")

m3_aug %>%
  group_by(ftreatment) %>%
  mutate(std_resid = residuals/sd(residuals),
         sqrt_abs_resid = sqrt(abs(std_resid))) %>%
  ggplot(aes(x = fitted, y = sqrt_abs_resid)) +
  geom_point(aes(col = freplicate)) +
  geom_smooth() +
  geom_hline(yintercept = 0.822, linetype = 2) + facet_wrap(~ftreatment) +
  labs(title = "Location-scale plot: model 3",
      x = "Fitted",
      y = "sqrt(abs(std.resid))",
      col = "Treatment") +
  theme(legend.position = "n")

# qqline
y <- quantile(m3$residuals, c(0.25, 0.75))
x <- qnorm(c(0.25, 0.75))
slope <- diff(y)/diff(x)
int <- y[1L] - slope * x[1L]

ggplot(m3_aug, aes(sample = residuals)) + stat_qq() + geom_abline(slope = slope, 
    intercept = int) + facet_wrap(~ftreatment)


m3_aug %>%
  ggplot(aes(x = l_total, y = residuals, col = freplicate)) +
  geom_jitter() +
  geom_hline(yintercept = 0, linetype = 2) +
  facet_wrap(~ftreatment) +
  labs(title = "residuals vs observed values",
      x = "observed ln(abundance)",
      col = "Treatment") +
  theme(legend.position = "n")

weevil %>%
  ggplot(aes(x = l_total, y = r, col = freplicate)) +
  geom_jitter() +
  geom_hline(yintercept = 0, linetype = 2) +
  facet_wrap(~ftreatment) +
  labs(title = "residuals vs observed values",
      x = "observed ln(abundance)",
      y = "population growth ln(N_t+1/N_t)",
      col = "Treatment") +
  theme(legend.position = "n")
```

## Population level prediction plots

```{r}
filter(sims_small, ftreatment == 0) %>%
  ggplot() +
  geom_line(aes(x = time*4, y = N, group = interaction(replicate,sim) ), col = "red", alpha = 0.5) +
  geom_line(data = filter(weevil, ftreatment == 0), mapping = aes(x = days - 32, y = total, group = replicate)) +
  facet_wrap(~replicate) +
   labs(title = "Gompertz model simulations with parameters from top model",
       y = "Abundance of adult bean weevil",
       subtitle = "0 % peanut shell",
         x = "Days since beginning of treatment",
       caption = "1 simulation per replicate.\nSimulations conditioned on inital population size in each replicate.")


```
```{r}
filter(sims_small, ftreatment == 0.05) %>%
  ggplot() +
  geom_line(aes(x = time*4, y = N, group = interaction(replicate,sim) ), col = "red", alpha = 0.5) +
  geom_line(data = filter(weevil, ftreatment == 0.05), mapping = aes(x = days - 32, y = total, group = replicate)) +
  facet_wrap(~replicate) +
   labs(title = "Gompertz model simulations with parameters from top model",
        subtitle = "5 % peanut shell",
       y = "Abundance of adult bean weevil",
         x = "Days since beginning of treatment",
       caption = "1 simulation per replicate.\nSimulations conditioned on inital population size in each replicate.")
```

```{r}
filter(sims_small, ftreatment == 0.1) %>%
  ggplot() +
  geom_line(aes(x = time*4, y = N, group = interaction(replicate,sim) ), col = "red", alpha = 0.5) +
  geom_line(data = filter(weevil, ftreatment == 0.1), mapping = aes(x = days - 32, y = total, group = replicate)) +
  facet_wrap(~replicate) +
   labs(title = "Gompertz model simulations with parameters from top model",
        subtitle = "10 % peanut shell",
       y = "Abundance of adult bean weevil",
         x = "Days since beginning of treatment",
       caption = "1 simulation per replicate.\nSimulations conditioned on inital population size in each replicate.")

```

```{r}
filter(sims_small, ftreatment == 0.15) %>%
  ggplot() +
  geom_line(aes(x = time*4, y = N, group = interaction(replicate,sim) ), col = "red", alpha = 0.5) +
  geom_line(data = filter(weevil, ftreatment == 0.15), mapping = aes(x = days - 32, y = total, group = replicate)) +
  facet_wrap(~replicate) +
   labs(title = "Gompertz model simulations with parameters from top model",
       y = "Abundance of adult bean weevil",
       subtitle = "15 % peanut shell",
         x = "Days since beginning of treatment",
       caption = "1 simulation per replicate.\nSimulations conditioned on inital population size in each replicate.")
```


```{r }
knitr::knit_exit()
```


# Boxplot of residuals

```{r}
augment(m3) %>%
  rename(fitted = .fitted, residuals= .resid) %>%
  group_by(ftreatment) %>%
  mutate(var_resid = var(residuals),
         resid_lwr = -1.96*var_resid,
         resid_upr = 1.96*var_resid) %>%
  ggplot(aes(x = as.factor(replicate), y = residuals)) +
  geom_boxplot() +
  geom_jitter(aes(col = ftreatment, shape = ftreatment),alpha = 0.4)  +
  geom_hline(yintercept = 0, linetype = 2, size = 1.5, alpha = 0.5) +
  coord_flip() +
  labs(title = "Residuals for ML estimated model",
       col = "treatment", shape = "treatment",
       x = "treatment x replicate") +
  facet_wrap(~ftreatment)
```

# More plots

```{r}
# increments for x and y axis
inc_total <- 5
inc_days <- 50 

# get max days and total, each rounded to the nearest value of inc_*
spark_lims <- 
  full_df %>% 
  select(days, total) %>% 
  summarise(max_days = ceiling(max(days)/inc_days)*inc_days, 
            max_total = ceiling(max(total)/inc_total) * inc_total )

spark_list <- lapply(seq_along(pct_peanut_shells),
                     function(x)
                       full_df %>%
  filter(treatment == pct_peanut_shells[x]) %>%
  ggplot(aes(x = days, y = total)) +
  geom_line() +
  scale_y_continuous(breaks = seq(0, spark_lims$max_total, by = 2*inc_total),
                     limits = c(0, spark_lims$max_total)) +
  scale_x_continuous(breaks = seq(0, spark_lims$max_days, by = 2*inc_days),
                     limits = c(0, spark_lims$max_days)) +
  labs(title = paste0(pct_peanut_shells[x]*100, " % peanut shell in food pellets")) +
  facet_wrap(~replicate))

# 0 % peanut shells
spark_list[[1]]
```

```{r}
spark_list[[3]]
```

```{r}
spark_list[[4]]
```

```{r}
spark_list[[5]]
```

```{r extinction_table}
weevil %>%
  group_by(treatment, replicate) %>%
  slice(1) %>%
  summarise(last_day) %>%
  filter(!is.na(last_day)) %>%
  arrange(treatment, replicate) %>%
  knitr::kable()
```

### log(next_abundance + 1) vs log(abundance + 1)

```{r plot_log_next_pop, fig.show="hold", out.width="50%"}
weevil %>%
  ggplot(aes(x = l_total, y = l_next_total)) +
  geom_point(aes(col = as.factor(replicate)), alpha = 0.4) +
  geom_smooth(method = "lm") +
  facet_wrap(~treatment) + theme(legend.position = "n")

weevil %>%
  ggplot(aes(x = l_total, y = l_next_total)) +
  geom_point(alpha = 0.4) +
  geom_smooth(method = "lm") +
  facet_grid(ftreatment ~ replicate)
```


```{r m3_resids, message=FALSE, warning = FALSE}
m3_aug %>%
  filter(ftreatment == 0) %>%
  ggplot(aes(x = fitted, y = residuals)) +
  geom_point() + 
  geom_smooth() +
  geom_hline(yintercept = 0, linetype = 2) +
  facet_wrap(~replicate) +
  labs(title = "Residual plot for one-step-ahead model",
       subtitle = "0 % shell")

m3_aug %>%
  filter(ftreatment == 0.05) %>%
  ggplot(aes(x = fitted, y = residuals)) +
  geom_point() + 
  geom_smooth() +
  geom_hline(yintercept = 0, linetype = 2) +
  facet_wrap(~replicate) +
  labs(title = "Residual plot for one-step-ahead model",
       subtitle = "5 % shell")

m3_aug %>%
  filter(ftreatment == 0.1) %>%
  ggplot(aes(x = fitted, y = residuals)) +
  geom_point() + 
  geom_smooth() +
  geom_hline(yintercept = 0, linetype = 2) +
  facet_wrap(~replicate) +
  labs(title = "Residual plot for one-step-ahead model",
       subtitle = "10 % shell")

m3_aug %>%
  filter(ftreatment == 0.15) %>%
  ggplot(aes(x = fitted, y = residuals)) +
  geom_point() + 
  geom_smooth() +
  geom_hline(yintercept = 0, linetype = 2) +
  facet_wrap(~replicate) +
  labs(title = "Residual plot for one-step-ahead model",
       subtitle = "15 % shell")
```

Plots of residuals vs. expected values look good for the one-step-ahead model.

Are the variances homogeneous across treatments?

```{r}
m3_aug %>%
  ggplot(aes(x = ftreatment, y = residuals)) +
  geom_boxplot() +
  geom_jitter(alpha = 0.2) 

m3_aug %>%
  ggplot(aes(x = rep_trt, y = residuals)) +
  geom_boxplot() +
  geom_jitter(aes(col = ftreatment, shape = ftreatment),alpha = 0.4)  +
  geom_hline(yintercept = 0, linetype = 2, size = 1.5, alpha = 0.5) +
  coord_flip() +
  labs(title = "Residuals for ML estimated model",
       col = "treatment", shape = "treatment",
       x = "treatment x replicate")

m3_aug %>%
  group_by(ftreatment) %>%
  mutate(resid_var = var(residuals)) %>%
  slice(1) %>%
  summarize(resid_var)

# p_reml_fit <- augment(pop_trt_reml, weevil) %>% rename("residuals" = .resid, "fitted" = .fitted)
# p_reml_fit %>%
#   ggplot(aes(x = rep_trt, y = residuals)) +
#   geom_boxplot() +
#   geom_jitter(aes(col = ftreatment),alpha = 0.2)  +
#   geom_hline(yintercept = 0, linetype = 2, size = 1.5, alpha = 0.5) +
#   coord_flip()

```


But is there any autocorrelation in residuals? Lets look visually first, then check using ACF or Ljung-Box tests.

```{r}
m3_aug %>%
  filter(ftreatment == 0) %>%
  ggplot(aes(x = days, y = residuals)) +
  geom_point() + 
  geom_smooth() +
  geom_hline(yintercept = 0, linetype = 2) +
  facet_wrap(~replicate) +
  labs(title = "Residual plot for one-step-ahead model",
       subtitle = "0 % shell")

m3_aug %>%
  filter(ftreatment == 0.05) %>%
  ggplot(aes(x = days, y = residuals)) +
  geom_point() + 
  geom_smooth() +
  geom_hline(yintercept = 0, linetype = 2) +
  facet_wrap(~replicate) +
  labs(title = "Residual plot for one-step-ahead model",
       subtitle = "5 % shell")

m3_aug %>%
  filter(ftreatment == 0.1) %>%
  ggplot(aes(x = days, y = residuals)) +
  geom_point() + 
  geom_smooth() +
  geom_hline(yintercept = 0, linetype = 2) +
  facet_wrap(~replicate) +
  labs(title = "Residual plot for one-step-ahead model",
       subtitle = "10 % shell")

m3_aug %>%
  filter(ftreatment == 0.15) %>%
  ggplot(aes(x = days, y = residuals)) +
  geom_point() + 
  geom_smooth() +
  geom_hline(yintercept = 0, linetype = 2) +
  facet_wrap(~replicate) +
  labs(title = "Residual plot for one-step-ahead model",
       subtitle = "15 % shell")
```

```{r}
knitr::knit_exit()
```

Trash heap below this point

To examine the effect of treatment specific variance in isolation I simulate the gompertz model using the fixed effects estimates for the control and the environmental variance estimates for each treatment.

```{r}
sims_vary_noise <- lapply(1:nrow(init_df), function(x)
  sim_log_gomp(xinit = unlist(init_df[x, "l_total"]),
             lambda = unlist(init_df[1, "a"]), 
             b = unlist(init_df[1,"b"]), 
             sd_proc = unlist(init_df[x,"trt_resid"]), 
             tfinal = unlist(init_df[x,"tfinal"]), 
             nsim = 1,
             replicate = unlist(init_df[x,"replicate"]),
             ftreatment = unlist(init_df[x,"ftreatment"]))
  ) %>%
  bind_rows()

sims_vary_noise %>%
  ggplot() +
  geom_line(aes(x = time*4, y = N, group = replicate), col = "red", alpha = 0.5) +
  #geom_line(data = weevil, mapping = aes(x = days - 32, y = total, group = replicate), alpha = 0.3) +
  facet_wrap(~ftreatment)
```

Hold all parameters at control but use factor specific population growth rate

```{r}
sims_vary_a <- lapply(1:nrow(init_df), function(x)
  sim_log_gomp(xinit = unlist(init_df[x, "l_total"]),
             lambda = unlist(init_df[x, "a"]), 
             b = unlist(init_df[1,"b"]), 
             sd_proc = unlist(init_df[1,"trt_resid"]), 
             tfinal = unlist(init_df[x,"tfinal"]), 
             nsim = 1,
             replicate = unlist(init_df[x,"replicate"]),
             ftreatment = unlist(init_df[x,"ftreatment"]))
  ) %>%
  bind_rows()

sims_vary_a %>%
  ggplot() +
  geom_line(aes(x = time*4, y = N, group = replicate), col = "red", alpha = 0.5) +
  #geom_line(data = weevil, mapping = aes(x = days - 32, y = total, group = replicate), alpha = 0.3) +
  facet_wrap(~ftreatment)
```

Hold all parameters at control but use factor specific density dependence

```{r}
sims_vary_b <- lapply(1:nrow(init_df), function(x)
  sim_log_gomp(xinit = unlist(init_df[x, "l_total"]),
             lambda = unlist(init_df[1, "a"]), 
             b = unlist(init_df[x,"b"]), 
             sd_proc = unlist(init_df[1,"trt_resid"]), 
             tfinal = unlist(init_df[x,"tfinal"]), 
             nsim = 1,
             replicate = unlist(init_df[x,"replicate"]),
             ftreatment = unlist(init_df[x,"ftreatment"]))
  ) %>%
  bind_rows()

sims_vary_b %>%
  ggplot() +
  geom_line(aes(x = time*4, y = N, group = replicate), col = "red", alpha = 0.5) +
  #geom_line(data = weevil, mapping = aes(x = days - 32, y = total, group = replicate), alpha = 0.3) +
  facet_wrap(~ftreatment)
```

```{r demo_possible_dynamics, eval = FALSE}
sens_par <- crossing(init = log(100),
       a = c(0.9, 1, 1.1),
       b = c(-0.5, - 0.25, 0.25, 0.75),
       sd = unlist(init_df[1,"trt_resid"]))

sims_sens <- lapply(1:nrow(sens_par), function(x)
  sim_log_gomp(xinit = unlist(sens_par[x, "init"]),
             lambda = unlist(sens_par[x, "a"]), 
             b = unlist(sens_par[x,"b"]), 
             sd_proc = unlist(sens_par[1,"sd"]), 
             tfinal = 100, 
             nsim = 5,
             replicate = 1,
             ftreatment = 1)
  ) %>%
  bind_rows()

sims_sens %>%
  ggplot() +
  geom_line(aes(x = time*4, y = N, group = sim), col = "red", alpha = 0.5) +
  #geom_line(data = weevil, mapping = aes(x = days - 32, y = total, group = replicate), alpha = 0.3) +
  facet_grid(lambda~b_, scales = "free")
  #facet_wrap(~b_, scale = "free_y")
```


```{r acf, eval = FALSE}
# need to write code to extract lag(1) acf
acf1 <- sims %>% filter(ftreatment == 0, replicate == 1, sim == 1) %>% pull(N) %>% acf(plot = FALSE, lag = 1)
acf1$acf[2]
```
